#! /bin/bash
#
# /etc/hotplug/usb/usb-storage
#
# PUT YOUR KNOWN DEVICES AND DEFAULT USER INTO "usb-storage-user.sh" !
#

[ -z $TYPE ] && exit 0

us_VERSION="20050718-devel"
KERNEL="$(uname -r)"

##########
#
# set to 1 if you want debugging output in $LOGFILE,
# set to 2 for Extended Debug (in find_partitions_26, fstype)
DEBUG=1
# set to 1 if you want logging appended to $LOGFILE.all
LOGALL=0
#
# Logfiles at /var/log/hotplug
LOGDIR=/var/log/hotplug
[ -d $LOGDIR ] || mkdir -p $LOGDIR

# When Debug = 0 -> Log Output to /dev/null
case $DEBUG in
    0) LOGFILE=/dev/null ;;
    *) LOGFILE=$LOGDIR/$(basename $0).log
       echo -n >$LOGFILE
       ;;
esac
# When LOGALL = 0 -> All Log Output to /dev/null
case $LOGALL in
    0) ALLFILE=/dev/null ;;
    *) ALLFILE=$LOGDIR/$(basename $0).log.all ;;
esac

function log {
    local LEVEL=$1; shift
    [ "$DEBUG" -ge "$LEVEL" ] && echo "$@" >>$LOGFILE
}
#
##########

log 1 "PRODUCT=$PRODUCT"
log 1 "KERNEL=$KERNEL"

echo "$ACTION $PRODUCT" >> $ALLFILE

# set default icon for storage devices
us_STORAGEICON=usbpendrive_mount
#
# set default values for special devices
# name is "camera", mountpoint is "/mnt/camera"
us_SPECIALNAME=camera
# default icon for camera
us_SPECIALICON=camera
#
# config file for known special devices
if [ -r "/etc/hotplug/usb/usb-storage-user.sh" ]; then
    source /etc/hotplug/usb/usb-storage-user.sh "$PRODUCT"
fi
#


function debugOutput {
cat << EOF
---
TYPE=$TYPE
ACTION=$ACTION
PRODUCT=$PRODUCT
INTERFACE=$INTERFACE
DEVICE=$DEVICE
DEVPATH=$DEVPATH
REMOVER=$REMOVER
EOF
set | grep '^us_'
echo "---"
}


function makeCameraIcon {
# make an icon (Camera) on Desktop
cat << EOF > $us_XDESKTOPFILE
[Desktop Entry]
Name=$us_SPECIALNAME
Type=Link
URL=$us_MOUNTPOINT
Actions=Sync;Digikam
Icon=$us_SPECIALICON
Comment=digital camera
Comment[de]=Digitalkamera

[Desktop Action Digikam]
Exec=/usr/bin/digikam;/bin/sync
Icon=camera
Name=Organize pictures
Name[de]=Bilder verwalten

[Desktop Action Sync]
Exec=/bin/sync
Icon=filesave
Name=Save changes
Name[de]=Änderungen speichern
EOF
# write a remover file to Autostart
cat << EOF > $us_XREMOVEFILE
#!/bin/sh
# remove stale camera icon if device not mounted
mount | grep -q $us_MOUNTPOINT || rm -f $us_XDESKTOPFILE $us_XREMOVEFILE
EOF
}


function makeStorageIcon {
# make an icon (USB stick) on Desktop
cat << EOF > $us_XDESKTOPFILE
[Desktop Entry]
Name=USB [$us_PARTITION]
Name[de]=USB [$us_PARTITION]
Type=Link
URL=$us_MOUNTPOINT
Actions=Sync
Icon=$us_STORAGEICON
Comment=USB storage device
Comment[de]=USB Speichergerät

[Desktop Action Sync]
Exec=/bin/sync
Icon=filesave
Name=Save changes
Name[de]=Änderungen speichern
EOF
# write a remover file to Autostart
cat << EOF > $us_XREMOVEFILE
#!/bin/sh
# remove stale USB storage icon if device not mounted
mount | grep -q $us_MOUNTPOINT || rm -f $us_XDESKTOPFILE $us_XREMOVEFILE
EOF
}



##########
#
#
#
function PRODUCT_to_SCSI {
        local GUID=$(echo $PRODUCT | awk -F/ '{printf "%04x%04x", strtonum("0x"$1), strtonum("0x"$2)}')
        grep -lr "^ *GUID: $GUID" /proc/scsi/usb-storage-* | xargs grep -l "^ *Attached: Yes" | cut -d/ -f5
}
#
##########


##########
#
# first detecting method
# doesn't work with multiple devices
#
function find_partitions_1 {
        sleep 1
        # find the last line with " sdx: sdxn", x=a,b,c,... and n=1,2,3,4
        dmesg | grep "^ \(sd[[:lower:]]\): \1[1234]" | tail -1 | tr -d \<\> | cut -d\  -f3-
}
#
##########


##########
#
# second detecting method
# uses scsidev command already in Kanotix
# doesn't work with kernel 2.6.x
#
function find_partitions_2 {
        local scsi=
        scsidev -lde 2>/dev/null >/dev/null
        for scsi in $(PRODUCT_to_SCSI $PRODUCT); do
                ls -l /dev/scsi/sdc${scsi}b0t?u?p*|cut -d/ -f6
        done
}
#
##########


##########
#
# third detecting method
#
function host_to_partitions {
        local host=$1
        local dev=
        for dev in $(scsiinfo -l); do
                local HOST="-1"
                eval $(scsi_info $dev 2>/dev/null)
                if [ $HOST = $host ]; then
                        cat /proc/partitions | grep $(basename ${dev})[1-9] | awk '{print $4}'
                fi
        done
}
#
#
function find_partitions_3 {
        local scsi=
        for scsi in $(PRODUCT_to_SCSI $PRODUCT); do
                host_to_partitions $scsi
        done
}
#
##########


##########
#
# (Not more so) simple detecting method for kernel 2.6.x
# (FJ's Version for hopefully 2.6.9- and 2.6.10+, with expiration timer)
function find_partitions_26 {
local FUNC=${FUNCNAME[0]}
local DEVS LOOP=50 LOOPTIME

# Warten, bis Phys. Device(s) erscheinen oder Timeout erreicht wird.
while [ -z "$DEVS" -a "$LOOP" -gt "0" ]; do
        DEVS=$(ls -d /sys$DEVPATH/host[0-9]*/target[0-9]*/[0-9]*:[0-9]:[0-9]:[0-9]/block) || \
        DEVS=$(ls -d /sys$DEVPATH/host[0-9]*/[0-9]*:[0-9]:[0-9]:[0-9]/block)
        (( LOOP-- ))
        sleep .5 # Wait 500 msec.
        log 2 "$FUNC: Date:$(date), DEVS:$DEVS"
done

# Wenn Device(s) gefunden -> Auswertung
LOOPTIME=$(( (50 - LOOP) * 500 ))
if [ -n "$DEVS" ]; then
        log 1 "$FUNC: Time in Loop: $LOOPTIME ms"
        local link= dev=
        for link in $DEVS; do
            dev=$(basename $(readlink $link))
            ls /sys/block/$dev | grep $dev || echo $dev
        done
else
        log 1 "$FUNC: Device not found in $LOOPTIME ms"
fi
log 2 "DEVS:$DEVS"
log 2 -e "$FUNC: DEBUG (ls -l \$DEVS):\n$(ls -l ${DEVS/block/} $DEVS/)\n"
log 2 -e "$FUNC: MOUNT:\n$(mount|grep -E "proc|sys|usb")\n"
log 2 -e "$FUNC: DMESG:\n$(dmesg|tail -25)\n"
}
#
##########


##########
#
function udev_subtle_sarge_hack {
# Devices in Eigenregie unter /dev erstellen (/sbin/MAKEDEV wird vorausgesetzt)
local FUNC=${FUNCNAME[0]}
if [ ! -b "$1" ]; then
        local PARTITION=${1/\/dev\/}; local DEV=${PARTITION:0:3}
        if [ ! -d /dev -o ! -x /sbin/MAKEDEV ]; then
            log 1 -e "$FUNC: No /dev Directory or /sbin/MAKEDEV is not there or executable. Too bad."
            exit 0
        fi
        log 1 -e "$FUNC: Make the Devicenodes for $PARTITION($DEV) under /dev (udev) manual with MAKEDEV.\n"
        (cd /dev; export WRITE_ON_UDEV="yes"; MAKEDEV $DEV) >>$LOGFILE 2>&1
fi
}
function udev_wait_for_blockdevice {
# Warten, bis Device unter 'dev' erscheint oder Timeout erreicht wird.
local FUNC=${FUNCNAME[0]}
local LOOP=150
while [ ! -b "$1" -a "$LOOP" -gt "0" ]; do
        (( LOOP-- ))
        sleep 1
        log 2 "$FUNC: Wait for Block Device $1 to settle, Tries $LOOP."
done
}
function udev_blockdevice {
case "$UDEV_SUBTLE_SARGE_HACK" in
        yes)    udev_subtle_sarge_hack $1 ;;
        *)      udev_wait_for_blockdevice $1 ;;
esac
}

function fstype {
local FUNC=${FUNCNAME[0]}
local FILE
dd if="$1" count=1 bs=1k >/dev/null 2>&1
if [ $? -gt 0 ]; then
        log 1 "$FUNC: 'dd if=$1 count=1 bs=1k' has failed. exists $1 ?"
        log 1 -e "DEBUG (ls -l ${1:0:8}*):\n$(ls -l ${1:0:8}*)"
        echo "none"
        return
fi
FILE="$(LANG=C LC_ALL=C LC_MESSAGES=C; file -Lkbs "$1")"
if [ $? -gt 0 ]; then
        log 1 "$FUNC: 'file -Lkbs $1' has failed."
        log 1 -e "FILE: $FILE\nDEBUG: $(file -Lkbs $1)"
        echo "none"
        return
fi
log 2 -e "$FUNC: FILE: $FILE\n"
log 2 -e "$FUNC: FDISK: $(fdisk -l ${1:0:8})\n"
if [ "$FILE" = "data" ]; then
        # could still be ReiserFS, since "file" only reads 64k in Debian
        FILE="$(dd if="$1" skip=65536 ibs=1 count=7 2>/dev/null)"
        case "$FILE" in
                *[Rr][Ee][Ii][Ss][Ee][Rr]4*);;
                *)FILE="$(dd if="$1" skip=65588 ibs=1 count=6 2>/dev/null)";;
        esac
fi
case "$FILE" in
        *extended\ partition\ table*) echo "extended";;
        *[Rr][Ee][Ii][Ss][Ee][Rr]4*)  echo "reiserfs";;
        *[Rr][Ee][Ii][Ss][Ee][Rr]*)   echo "reiserfs";;
        *ISO\ 9660*)                  echo "iso9660";;
        *[Mm][Ii][Nn][Ii][Xx]*)       echo "minix";;
        *[Xx][Ff][Ss]*)               echo "xfs";;
        *[Jj][Ff][Ss]*)               echo "jfs";;
        *[Ee][Xx][Tt]3*)              echo "ext3";;
        *[Ee][Xx][Tt]2*)              echo "ext2";;
        *[Ss][Ww][Aa][Pp]*)           echo "swap";;
        *[Nn][Tt][Ff][Ss]*)           echo "ntfs";;
        *[Ff][Aa][Tt]*)               echo "vfat";;
        x86\ boot\ sector*)
               # check FAT12 / FAT16
                dd if="$1" ibs=1 skip=54 count=8 2>/dev/null | grep -q FAT && echo "vfat" && return
                # check FAT32
                dd if="$1" ibs=1 skip=82 count=8 2>/dev/null | grep -q FAT && echo "vfat" && return
                echo "auto"
                ;;
        *)                            echo "auto";;
esac
}
#
##########


if [ "$DEVPATH" ]; then
        us_PARTITIONS=$(find_partitions_26)
else
        us_PARTITIONS=$(find_partitions_3)
fi


if [ -z "$us_PARTITIONS" ]; then
        log 1 "Device not found"
        log 1 "$(debugOutput)"
        exit 0
fi


echo "#!/bin/sh" > $REMOVER
chmod a+x $REMOVER

# find X11 user
#us_XUSER=$(who | grep " :0" | cut -d\  -f1)
us_XUSER=$(ls -ot /tmp/.ICE-unix/[1-9]* 2>/dev/null | awk '{print $3}' | head -1)
if [ $us_XUSER ]; then # user logged in at X11
        XUID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f3)
        XGID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f4)
        us_OWNER="uid=$XUID,gid=$XGID"
elif [ -d /KNOPPIX/Desktop ]; then # we're running from live CD
        us_XUSER=knoppix
        XUID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f3)
        XGID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f4)
        us_OWNER="uid=$XUID,gid=$XGID"
elif [ $us_DEFAULTUSER ]; then # use Desktop and uid/gid of this user
        us_XUSER=$us_DEFAULTUSER
        XUID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f3)
        XGID=$(grep "^$us_XUSER:" /etc/passwd | cut -d: -f4)
        us_OWNER="uid=$XUID,gid=$XGID"
elif [ $us_DEFAULTUID ]; then # use default uid and gid of this users                 
        us_XUSER=$(grep ".*:.*:$us_DEFAULTUID:.*" /etc/passwd | cut -d: -f1)
        XGID=$(grep ".*:.*:$us_DEFAULTUID:.*" /etc/passwd | cut -d: -f4)
        us_OWNER="uid=$us_DEFAULTUID,gid=$XGID"
else
        us_OWNER="gid=100"
fi

# mount all partitions on the USB device
for us_PARTITION in $us_PARTITIONS; do
        us_DEVICE=/dev/$us_PARTITION

        # special case for digicam
        if [ "$us_SPECIALDEVICE" ]; then
            us_MOUNTPOINT=/mnt/$us_SPECIALNAME
        else
            us_MOUNTPOINT=/mnt/$us_PARTITION
        fi

        # skip if device or mountpoint already in use
        # TODO: umount mounted devices always at remove
        mount | grep "$us_DEVICE \| $us_MOUNTPOINT " >/dev/null
        if [ $? -eq 0 ]; then
                log 1 -n "Already mounted: "
                log 1 "$(mount | grep "$us_DEVICE\|$us_MOUNTPOINT")"
                _DEBUG=1
                continue
        fi

        # Make sure, that the Device was there
        udev_blockdevice $us_DEVICE
    
        # check filesystem type
        if [ "$us_SPECIALDEVICE" ]; then
                us_FSTYPE="vfat"
        else
                us_FSTYPE=$(fstype $us_DEVICE)
        fi

        log 1 "$us_DEVICE $us_FSTYPE"

        case "$us_FSTYPE" in
                ext2|ext3|reiserfs|jfs|xfs|minix)
                        us_MOUNTCMD="/bin/mount -t $us_FSTYPE -o user $us_DEVICE $us_MOUNTPOINT"
                        ;;
                ntfs)
                        # TODO: add useful options
                        us_MOUNTCMD="/bin/mount -t $us_FSTYPE -o $us_OWNER,umask=0222,ro,user $us_DEVICE $us_MOUNTPOINT"
                        ;;
                vfat|auto)
                        # Better implementation, with bash-Syntax (without 'cut')
                        VFAT_MAINVER=${KERNEL/\-*/}
                        [ "${VFAT_MAINVER:0:3}" != "2.6" -o "${VFAT_MAINVER:4:3}" -lt "12" ] && VFAT_SYNC=",sync"
                        us_MOUNTCMD="/bin/mount -t vfat -s -o $us_OWNER,shortname=mixed,quiet${VFAT_SYNC},umask=0002,user,showexec $us_DEVICE $us_MOUNTPOINT"
                        ;;
                none|extended|swap)
                        continue
                        ;;
                *)
                        # don't mount
                        log 1 "$us_DEVICE $us_FSTYPE"
                        continue
                        ;;
        esac

        # try to mount
        mkdir -p $us_MOUNTPOINT
        log 1 "$us_MOUNTCMD"
        $($us_MOUNTCMD 2>> $LOGFILE)
        # continue if no success
        if [ $? -ne 0 ]; then
                continue
        fi

        # $REMOVER is executed when the device is pulled
        echo "/bin/umount -lf $us_DEVICE" >> $REMOVER
        echo "echo \"/bin/umount -lf $us_DEVICE\" >> $LOGFILE" >> $REMOVER

        # Logging
        echo "echo \"umount $us_DEVICE\" >> $ALLFILE" >> $REMOVER
        echo "umount $us_DEVICE" >> $ALLFILE

        # Desktop icon for X11
        for home in $(awk -F: '{print $6}' /etc/passwd); do
                desktop=${home}/Desktop
                if [ -d "$desktop" ]; then
                        case "$us_SPECIALDEVICE" in
                                camera)
                    us_XDESKTOPFILE="$desktop/${us_SPECIALNAME}.desktop"
                    us_XREMOVEFILE="$home/.kde/Autostart/rm_icon_${us_SPECIALNAME}"
                                        makeCameraIcon
                                        ;;
                                *)
                    us_XDESKTOPFILE="$desktop/USB_${us_PARTITION}.desktop"
                    us_XREMOVEFILE="$home/.kde/Autostart/rm_icon_USB_${us_PARTITION}"
                                        makeStorageIcon
                                        ;;
                        esac
                        chown --reference=$desktop $us_XDESKTOPFILE $us_XREMOVEFILE
                        chmod +x $us_XREMOVEFILE
                        echo "rm -f $us_XDESKTOPFILE" >> $REMOVER
                        echo "rm -f $us_XREMOVEFILE" >> $REMOVER
                fi
        done

        sleep 1
done

log 1 "$(debugOutput)"

# hack for "coldplugging" (make $REMOVER newer then /etc/mtab created by mount cmd)
# older files are removed when /etc/init.d/bootmisc.sh is run
sleep 1
echo >> $REMOVER
